%% Variables and constants

% [x y z] : quadrotor linear position in earth frame
% [theta phi psi] : quadrotor angular position in earth frame
syms x y z theta phi psi real

% [u v w] : quadrotor linear velocities
% [p q r] : quadrotor angular velocities
syms u v w p q r real
syms xd yd zd real

% Inertia matrix
syms Ix Iy Iz positive real

% [fw_x fw_y fw_z]: forces produced by wind
syms fw_x fw_y fw_z real

% [tau_x tau_y tau_z]: control torques generated by differences in the
% rotor speeds
% [tau_wx tau_wy tau_wz]: torques produced by wind
syms tau_x tau_y tau_z real
syms tau_wx tau_wy tau_wz real

% Total thrust generated by rotors
syms f_t real

% Quadrotor mass
syms m positive real

% System state array
state = [x y z psi theta phi xd yd zd p q r];

% Parameters array
pars = [Ix Iy Iz m];

% Gravitational accelaration
g = 9.81;

% Numerical values out of "Robotics, vision and control - P. Corke" example
Ix_num = 0.0820; % [kg/m^2]
Iy_num = 0.0845; % [kg/m^2]
Iz_num = 0.1377; % [kg/m^2]
m_num = 4.34; % [kg]

pars_num = [Ix_num Iy_num Iz_num m_num];

% Flags
is_stla = false;
is_stlc = false;
is_lo = false;

%% Initial conditions
state0 = [0 0 0 0 0 0 0 0 0 0 0 0];

%% Dynamic system
fprintf("Quadrotor system considered:")
Xdot = w * (sin(phi) * sin(psi) + cos(phi) * cos(psi) * sin(theta)) - v * (cos(phi) * sin(psi) - cos(psi) * sin(phi) * sin(theta)) + u * (cos(psi) * cos(theta))
Ydot = v * (cos(phi) * cos(psi) + sin(phi) * sin(psi) * sin(theta)) - w * (cos(psi) * sin(phi) - cos(phi) * sin(psi) * sin(theta)) + u * (cos(theta) * sin(psi))
Zdot = w * (cos(phi) * cos(theta)) - u * (sin(theta)) + v * (cos(theta) * sin(phi))
Phidot = p + r * (cos(phi) * tan(theta)) + q * (sin(phi) * tan(theta))
Thetadot = q * cos(phi) - r * sin(phi)
Psidot = r * cos(phi) / cos(theta) + q * sin(phi) / cos(theta)
Pdot = (Iy - Iz) / Ix * r * q + (tau_x + tau_wx) / Ix
Qdot = (Iz - Ix) / Iy * p * r + (tau_y + tau_wy) / Iy
Rdot = (Ix - Iy) / Iz * p * q + (tau_z + tau_wz) / Iz
Udot = r * v - q * w - g * sin(theta) + fw_x / m
Vdot = p * w - r * u + g * sin(phi) * cos(theta) + fw_y / m
Wdot = q * u - p * v + g * cos(theta) * cos(phi) + (fw_z - f_t) / m

%% Vector fields and distributions describing the system

% Control input field
% Considering tau_i, tau_wi, fw_i, ft as separate inputs
% inputs = [tau_x tau_y tau_z tau_wx tau_wy tau_wz fw_x fw_y fw_z f_t];
syms u1 u2 u3 u4
g7_1 = - 1/m * (sin(phi)*sin(psi) + cos(phi)*cos(psi)*sin(theta));
g8_1 = - 1/m * (sin(phi)*cos(psi) - cos(phi)*sin(psi)*sin(theta));
g9_1 = - 1/m * cos(phi) * cos(psi);
g1 = [0 0 0 0 0 0 g7_1 g8_1 g9_1 0 0 0]';
g2 = [0 0 0 0 0 0 0 0 0 1/Ix 0 0]';
g3 = [0 0 0 0 0 0 0 0 0 0 1/Iy 0]';
g4 = [0 0 0 0 0 0 0 0 0 0 0 1/Iz]';
G = [g1 g2 g3 g4];

% Drift vector field
f = [xd;
     yd;
     zd;
     r * cos(phi) / cos(theta) + q * sin(phi) / cos(theta);
     q  * cos(phi) - r * sin(phi);
     p + r * (cos(phi) * tan(theta)) + q * (sin(phi) * tan(theta));
     0;
     0;
     g;
     (Iy - Iz) / Ix * r * q;
     (Iz - Ix) / Iy * p * r;
     (Ix - Iy) / Iz * p * q
    ];

% Distributions
delta0 = G;
delta = [f G];

% Output functions
chosen_output = [x; y; z; psi];