%% Setup
clc; clear all; close all;

%% Variables and constants

% [x y z] : quadrotor linear position in earth frame
% [theta phi psi] : quadrotor angular position in earth frame
syms x y z theta phi psi real

% [u v w] : quadrotor linear velocities
% [p q r] : quadrotor angular velocities
syms u v w p q r real

% Inertia matrix
syms Ix Iy Iz positive real

% [fw_x fw_y fw_z]: forces produced by wind
syms fw_x fw_y fw_z real

% [tau_x tau_y tau_z]: control torques generated by differences in the
% rotor speeds
% [tau_wx tau_wy tau_wz]: torques produced by wind
syms tau_x tau_y tau_z real
syms tau_wx tau_wy tau_wz real

% Total thrust generated by rotors
syms f_t real

% Quadrotor mass
syms m positive real

% System state array
state = [x y z phi theta psi p q r u v w];

% Parameters array
pars = [Ix Iy Iz m];

% Gravitational accelaration
g = 9.81;

% Numerical values out of "Robotics, vision and control - P. Corke" example
Ix_num = 0.0820; % [kg/m^2]
Iy_num = 0.0845; % [kg/m^2]
Iz_num = 0.1377; % [kg/m^2]
m_num = 4.34; % [kg]

pars_num = [Ix_num Iy_num Iz_num m_num];

% Flags
is_stla = false;
is_stlc = false;
is_lo = false;

%% Initial conditions
state0 = [0 0 0 0 0 0 0 0 0 0 0 0];

%% Dynamic system
fprintf("Quadrotor system considered:")
Xdot = w * (sin(phi) * sin(psi) + cos(phi) * cos(psi) * sin(theta)) - v * (cos(phi) * sin(psi) - cos(psi) * sin(phi) * sin(theta)) + u * (cos(psi) * cos(theta))
Ydot = v * (cos(phi) * cos(psi) + sin(phi) * sin(psi) * sin(theta)) - w * (cos(psi) * sin(phi) - cos(phi) * sin(psi) * sin(theta)) + u * (cos(theta) * sin(psi))
Zdot = w * (cos(phi) * cos(theta)) - u * (sin(theta)) + v * (cos(theta) * sin(phi))
Phidot = p + r * (cos(phi) * tan(theta)) + q * (sin(phi) * tan(theta))
Thetadot = q * cos(phi) - r * sin(phi)
Psidot = r * cos(phi) / cos(theta) + q * sin(phi) / cos(theta)
Pdot = (Iy - Iz) / Ix * r * q + (tau_x + tau_wx) / Ix
Qdot = (Iz - Ix) / Iy * p * r + (tau_y + tau_wy) / Iy
Rdot = (Ix - Iy) / Iz * p * q + (tau_z + tau_wz) / Iz
Udot = r * v - q * w - g * sin(theta) + fw_x / m
Vdot = p * w - r * u + g * sin(phi) * cos(theta) + fw_y / m
Wdot = q * u - p * v + g * cos(theta) * cos(phi) + (fw_z - f_t) / m

%% Vector fields and distributions describing the system

% Control input field
% Considering tau_i, tau_wi, fw_i, ft as separate inputs
% Reminder: state = [x y z phi theta psi p q r u v w];
inputs = [tau_x tau_y tau_z tau_wx tau_wy tau_wz fw_x fw_y fw_z f_t];
g1 = [0 0 0 0 0 0 1/Ix 0 0 0 0 0]';
g2 = [0 0 0 0 0 0 0 1/Iy 0 0 0 0]';
g3 = [0 0 0 0 0 0 0 0 1/Iz 0 0 0]';
g4 = [0 0 0 0 0 0 1/Ix 0 0 0 0 0]';
g5 = [0 0 0 0 0 0 0 1/Iy 0 0 0 0]';
g6 = [0 0 0 0 0 0 0 0 1/Iz 0 0 0]';
g7 = [0 0 0 0 0 0 0 0 0 1/m 0 0]';
g8 = [0 0 0 0 0 0 0 0 0 0 1/m 0]';
g9 = [0 0 0 0 0 0 0 0 0 0 0 1/m]';
g10 = [0 0 0 0 0 0 0 0 0 0 0 -1/m]';
G = [g1 g2 g3 g4 g5 g6 g7 g8 g9 g10];

% Drift vector field
f = [w * (sin(phi) * sin(psi) + cos(phi) * cos(psi) * sin(theta)) - v * (cos(phi) * sin(psi) - cos(psi) * sin(phi) * sin(theta)) + u * (cos(psi) * cos(theta));
     v * (cos(phi) * cos(psi) + sin(phi) * sin(psi) * sin(theta)) - w * (cos(psi) * sin(phi) - cos(phi) * sin(psi) * sin(theta)) + u * (cos(theta) * sin(psi));
     w * (cos(phi) * cos(theta)) - u * (sin(theta)) + v * (cos(theta) * sin(phi));
     p + r * (cos(phi) * tan(theta)) + q * (sin(phi) * tan(theta));
     q  * cos(phi) - r * sin(phi);
     r * cos(phi) / cos(theta) + q * sin(phi) / cos(theta);
     (Iy - Iz) / Ix * r * q;
     (Iz - Ix) / Iy * p * r;
     (Ix - Iy) / Iz * p * q;
     r * v - q * w - g * sin(theta);
     p * w - r * u + g * sin(phi) * cos(theta);
     q * u - p * v + g * cos(theta) * cos(phi)
    ];

% Distributions
delta0 = G;
delta = [f G];

%% Small time local accessibility
% To study the stla of the system we use the Chow Filtration theorem, based on 
% the accessibility distribution

delta_min = AccFiltration(delta, delta0, state);

if rank(subs(delta_min, [state, pars], [state0, pars_num])) == length(state)
    fprintf("The system is stla \n")
    is_stla = true;
else
    fprintf("The system is not stla \n")
end

%% Weak local accessibility

if is_stla
    fprintf("The system is stla, so it is also weak locally accessible \n")
else
    delta_weak = AccFiltration(delta, delta, state);

    if rank(subs(delta_weak, [state, pars], [state0, pars_num])) == length(state)
        fprintf("The system is wla \n")
        is_stla = true;
    else
        fprintf("The system is not wla \n")
    end
    
end

%% Small time local controllability

[is_stlc, matched_cond] = STLCCheck(f, G, state, pars, state0, pars_num);

if is_stlc
    fprintf("The system is stlc \n")
    is_stlc = true;
else
    fprintf("The system is not stlc \n")
end
%% Local observability

fprintf("We choose the quadrotor position as output of the system: \n")
h = [x, y, z, 0, 0, 0, 0, 0, 0, 0, 0, 0]

dh = jacobian(h, state);
gamma0 = dh;

gamma_min = ObsFiltration(delta, gamma0, state);

rgm = rank(gamma_min);

if rgm == length(state)
    fprintf("The Observability matrix has full rank in the general symbolic " + ...
        "form, so the system can be locally observable with this output " + ...
        "choice. \n");

    gamma_min_num = subs(gamma_min, [state, pars], [state0, pars_num]);
    rgm_num = rank(gamma_min_num);

    if rgm_num == length(state)
        fprintf("The Observability matrix has full rank in the specified " + ...
            "inital conditions, so the system is locally observable \n");
    else
        fprintf("The Observability matrix has rank %d in the specified inital " + ...
            "conditions, so the system is not locally observable \n", rgm_num);
    end

else
    fprintf("The Observability matrix has rank %d in the general symbolic " + ...
        "form, so the system cannot be locally observable with this output " + ...
        "choice. \n", rgm);
end
