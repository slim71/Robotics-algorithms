%% Variables and constants

% [x y z] : quadrotor linear position in earth frame
% [theta phi psi] : quadrotor angular position in earth frame
syms x y z theta phi psi real

% [u v w] : quadrotor linear velocities
% [p q r] : quadrotor angular velocities
syms u v w p q r real

% Inertia matrix
syms Ix Iy Iz positive real

% [fw_x fw_y fw_z]: forces produced by wind
syms fw_x fw_y fw_z real

% [tau_x tau_y tau_z]: control torques generated by differences in the
% rotor speeds
% [tau_wx tau_wy tau_wz]: torques produced by wind
syms tau_x tau_y tau_z real
syms tau_wx tau_wy tau_wz real

% Total thrust generated by rotors
syms f_t real

% Quadrotor mass
syms m positive real

% System state array
state = [x y z phi theta psi p q r u v w];

% Parameters array
pars = [Ix Iy Iz m];

% Gravitational accelaration
g = 9.81;

% Numerical values out of "Robotics, vision and control - P. Corke" example
Ix_num = 0.0820; % [kg/m^2]
Iy_num = 0.0845; % [kg/m^2]
Iz_num = 0.1377; % [kg/m^2]
m_num = 4.34; % [kg]

pars_num = [Ix_num Iy_num Iz_num m_num];

% Flags
is_stla = false;
is_stlc = false;
is_lo = false;

%% Initial conditions
state0 = [0 0 0 0 0 0 0 0 0 0 0 0];

%% Dynamic system
fprintf("Quadrotor system considered:")
Xdot = w * (sin(phi) * sin(psi) + cos(phi) * cos(psi) * sin(theta)) - v * (cos(phi) * sin(psi) - cos(psi) * sin(phi) * sin(theta)) + u * (cos(psi) * cos(theta))
Ydot = v * (cos(phi) * cos(psi) + sin(phi) * sin(psi) * sin(theta)) - w * (cos(psi) * sin(phi) - cos(phi) * sin(psi) * sin(theta)) + u * (cos(theta) * sin(psi))
Zdot = w * (cos(phi) * cos(theta)) - u * (sin(theta)) + v * (cos(theta) * sin(phi))
Phidot = p + r * (cos(phi) * tan(theta)) + q * (sin(phi) * tan(theta))
Thetadot = q * cos(phi) - r * sin(phi)
Psidot = r * cos(phi) / cos(theta) + q * sin(phi) / cos(theta)
Pdot = (Iy - Iz) / Ix * r * q + (tau_x + tau_wx) / Ix
Qdot = (Iz - Ix) / Iy * p * r + (tau_y + tau_wy) / Iy
Rdot = (Ix - Iy) / Iz * p * q + (tau_z + tau_wz) / Iz
Udot = r * v - q * w - g * sin(theta) + fw_x / m
Vdot = p * w - r * u + g * sin(phi) * cos(theta) + fw_y / m
Wdot = q * u - p * v + g * cos(theta) * cos(phi) + (fw_z - f_t) / m

%% Vector fields and distributions describing the system

% Control input field
% Considering tau_i, tau_wi, fw_i, ft as separate inputs
% Reminder: state = [x y z phi theta psi p q r u v w];
inputs = [tau_x tau_y tau_z tau_wx tau_wy tau_wz fw_x fw_y fw_z f_t];
g1 = [0 0 0 0 0 0 1/Ix 0 0 0 0 0]';
g2 = [0 0 0 0 0 0 0 1/Iy 0 0 0 0]';
g3 = [0 0 0 0 0 0 0 0 1/Iz 0 0 0]';
g4 = [0 0 0 0 0 0 1/Ix 0 0 0 0 0]';
g5 = [0 0 0 0 0 0 0 1/Iy 0 0 0 0]';
g6 = [0 0 0 0 0 0 0 0 1/Iz 0 0 0]';
g7 = [0 0 0 0 0 0 0 0 0 1/m 0 0]';
g8 = [0 0 0 0 0 0 0 0 0 0 1/m 0]';
g9 = [0 0 0 0 0 0 0 0 0 0 0 1/m]';
g10 = [0 0 0 0 0 0 0 0 0 0 0 -1/m]';
G = [g1 g2 g3 g4 g5 g6 g7 g8 g9 g10];

% Drift vector field
f = [w * (sin(phi) * sin(psi) + cos(phi) * cos(psi) * sin(theta)) - v * (cos(phi) * sin(psi) - cos(psi) * sin(phi) * sin(theta)) + u * (cos(psi) * cos(theta));
     v * (cos(phi) * cos(psi) + sin(phi) * sin(psi) * sin(theta)) - w * (cos(psi) * sin(phi) - cos(phi) * sin(psi) * sin(theta)) + u * (cos(theta) * sin(psi));
     w * (cos(phi) * cos(theta)) - u * (sin(theta)) + v * (cos(theta) * sin(phi));
     p + r * (cos(phi) * tan(theta)) + q * (sin(phi) * tan(theta));
     q  * cos(phi) - r * sin(phi);
     r * cos(phi) / cos(theta) + q * sin(phi) / cos(theta);
     (Iy - Iz) / Ix * r * q;
     (Iz - Ix) / Iy * p * r;
     (Ix - Iy) / Iz * p * q;
     r * v - q * w - g * sin(theta);
     p * w - r * u + g * sin(phi) * cos(theta);
     q * u - p * v + g * cos(theta) * cos(phi)
    ];

% Distributions
delta0 = G;
delta = [f G];

% Output functions
chosen_output = [x; y; z; theta; phi; psi; p; q; r; u];